import { IonicNativePlugin } from '@ionic-native/core';
import * as Éµngcc0 from '@angular/core';
export interface HTTPResponse {
    /**
     * The HTTP status number of the response or a negative internal error code.
     */
    status: number;
    /**
     * The headers of the response.
     */
    headers: {
        [key: string]: string;
    };
    /**
     * The URL of the response. This property will be the final URL obtained after any redirects.
     */
    url: string;
    /**
     * The data that is in the response. This property usually exists when a promise returned by a request method resolves.
     */
    data?: any;
    /**
     * Error response from the server. This property usually exists when a promise returned by a request method rejects.
     */
    error?: string;
}
interface AbortedResponse {
    aborted: boolean;
}
/**
 * @name HTTP
 * @description
 * Cordova / Phonegap plugin for communicating with HTTP servers. Supports iOS and Android.
 *
 * Advantages over Javascript requests:
 * - SSL / TLS Pinning
 * - CORS restrictions do not apply
 * - Handling of HTTP code 401 - read more at [Issue CB-2415](https://issues.apache.org/jira/browse/CB-2415)
 *
 * @usage
 * ```typescript
 * import { HTTP } from '@ionic-native/http/ngx';
 *
 * constructor(private http: HTTP) {}
 *
 * ...
 *
 * this.http.get('http://ionic.io', {}, {})
 *   .then(data => {
 *
 *     console.log(data.status);
 *     console.log(data.data); // data received by server
 *     console.log(data.headers);
 *
 *   })
 *   .catch(error => {
 *
 *     console.log(error.status);
 *     console.log(error.error); // error message as string
 *     console.log(error.headers);
 *
 *   });
 *
 * ```
 * @interfaces
 * HTTPResponse
 */
export declare class HTTP extends IonicNativePlugin {
    /**
     * This enum represents the internal error codes which can be returned in a HTTPResponse object.
     * @readonly
     */
    readonly ErrorCode: {
        GENERIC: number;
        SSL_EXCEPTION: number;
        SERVER_NOT_FOUND: number;
        TIMEOUT: number;
        UNSUPPORTED_URL: number;
        NOT_CONNECTED: number;
        POST_PROCESSING_FAILED: number;
        ABORTED: number;
    };
    /**
     * This returns an object representing a basic HTTP Authorization header of the form.
     * @param username {string} Username
     * @param password {string} Password
     * @returns {Object} an object representing a basic HTTP Authorization header of the form {'Authorization': 'Basic base64EncodedUsernameAndPassword'}
     */
    getBasicAuthHeader(username: string, password: string): {
        Authorization: string;
    };
    /**
     * This sets up all future requests to use Basic HTTP authentication with the given username and password.
     * @param username {string} Username
     * @param password {string} Password
     */
    useBasicAuth(username: string, password: string): void;
    /**
     * Get all headers defined for a given hostname.
     * @param host {string} The hostname
     * @returns {string} return all headers defined for the hostname
     */
    getHeaders(host: string): string;
    /**
     * Set a header for all future requests. Takes a hostname, a header and a value.
     * @param host {string} The hostname to be used for scoping this header
     * @param header {string} The name of the header
     * @param value {string} The value of the header
     */
    setHeader(host: string, header: string, value: string): void;
    /**
     * Get the name of the data serializer which will be used for all future POST and PUT requests.
     * @returns {string} returns the name of the configured data serializer
     */
    getDataSerializer(): string;
    /**
     * Set the data serializer which will be used for all future POST, PUT and PATCH requests. Takes a string representing the name of the serializer.
     * @param serializer {string} The name of the serializer.
     * @see https://github.com/silkimen/cordova-plugin-advanced-http#setdataserializer
     */
    setDataSerializer(serializer: 'urlencoded' | 'json' | 'utf8' | 'multipart' | 'raw'): void;
    /**
     * Add a custom cookie.
     * @param url {string} Scope of the cookie
     * @param cookie {string} RFC compliant cookie string
     */
    setCookie(url: string, cookie: string): void;
    /**
     * Clear all cookies.
     */
    clearCookies(): void;
    /**
     * Remove cookies for given URL.
     * @param url {string}
     * @param cb
     */
    removeCookies(url: string, cb: () => void): void;
    /**
     * Resolve cookie string for given URL.
     * @param url {string}
     */
    getCookieString(url: string): string;
    /**
     * Get global request timeout value in seconds.
     * @returns {number} returns the global request timeout value
     */
    getRequestTimeout(): number;
    /**
     * Set global request timeout value in seconds.
     * @param timeout {number} The timeout in seconds. Default 60
     */
    setRequestTimeout(timeout: number): void;
    /**
     * Resolve if it should follow redirects automatically.
     * @returns {boolean} returns true if it is configured to follow redirects automatically
     */
    getFollowRedirect(): boolean;
    /**
     * Configure if it should follow redirects automatically.
     * @param follow {boolean} Set to false to disable following redirects automatically
     */
    setFollowRedirect(follow: boolean): void;
    /**
     * Set server trust mode, being one of the following values:
     * default: default SSL trustship and hostname verification handling using system's CA certs;
     * legacy: use legacy default behavior (< 2.0.3), excluding user installed CA certs (only for Android);
     * nocheck: disable SSL certificate checking and hostname verification, trusting all certs (meant to be used only for testing purposes);
     * pinned: trust only provided certificates;
     * @see https://github.com/silkimen/cordova-plugin-advanced-http#setservertrustmode
     * @param {string} mode server trust mode
     */
    setServerTrustMode(mode: 'default' | 'legacy' | 'nocheck' | 'pinned'): Promise<void>;
    /**
     * Make a POST request
     * @param url {string} The url to send the request to
     * @param body {Object} The body of the request
     * @param headers {Object} The headers to set for this request
     * @returns {Promise<HTTPResponse>} returns a promise that will resolve on success, and reject on failure
     */
    post(url: string, body: any, headers: any): Promise<HTTPResponse>;
    /**
     * Make a sync POST request
     * @param url {string} The url to send the request to
     * @param body {Object} The body of the request
     * @param headers {Object} The headers to set for this request
     * @param success {function} A callback that is called when the request succeed
     * @param failure {function} A callback that is called when the request failed
     * @returns {string} returns a string that represents the requestId
     */
    postSync(url: string, body: any, headers: any, success: (result: HTTPResponse) => void, failure: (error: any) => void): string;
    /**
     * Make a GET request
     * @param url {string} The url to send the request to
     * @param parameters {Object} Parameters to send with the request
     * @param headers {Object} The headers to set for this request
     * @returns {Promise<HTTPResponse>} returns a promise that will resolve on success, and reject on failure
     */
    get(url: string, parameters: any, headers: any): Promise<HTTPResponse>;
    /**
     * Make a sync GET request
     * @param url {string} The url to send the request to
     * @param parameters {Object} Parameters to send with the request
     * @param headers {Object} The headers to set for this request
     * @param success {function} A callback that is called when the request succeed
     * @param failure {function} A callback that is called when the request failed
     * @returns {string} returns a string that represents the requestId
     */
    getSync(url: string, parameters: any, headers: any, success: (result: HTTPResponse) => void, failure: (error: any) => void): string;
    /**
     * Make a PUT request
     * @param url {string} The url to send the request to
     * @param body {Object} The body of the request
     * @param headers {Object} The headers to set for this request
     * @returns {Promise<HTTPResponse>} returns a promise that will resolve on success, and reject on failure
     */
    put(url: string, body: any, headers: any): Promise<HTTPResponse>;
    /**
     * Make a sync PUT request
     * @param url {string} The url to send the request to
     * @param body {Object} The body of the request
     * @param headers {Object} The headers to set for this request
     * @param success {function} A callback that is called when the request succeed
     * @param failure {function} A callback that is called when the request failed
     * @returns {string} returns a string that represents the requestId
     */
    putSync(url: string, body: any, headers: any, success: (result: HTTPResponse) => void, failure: (error: any) => void): string;
    /**
     * Make a PATCH request
     * @param url {string} The url to send the request to
     * @param body {Object} The body of the request
     * @param headers {Object} The headers to set for this request
     * @returns {Promise<HTTPResponse>} returns a promise that will resolve on success, and reject on failure
     */
    patch(url: string, body: any, headers: any): Promise<HTTPResponse>;
    /**
     * Make a sync PATCH request
     * @param url {string} The url to send the request to
     * @param body {Object} The body of the request
     * @param headers {Object} The headers to set for this request
     * @param success {function} A callback that is called when the request succeed
     * @param failure {function} A callback that is called when the request failed
     * @returns {string} returns a string that represents the requestId
     */
    patchSync(url: string, body: any, headers: any, success: (result: HTTPResponse) => void, failure: (error: any) => void): string;
    /**
     * Make a DELETE request
     * @param url {string} The url to send the request to
     * @param parameters {Object} Parameters to send with the request
     * @param headers {Object} The headers to set for this request
     * @returns {Promise<HTTPResponse>} returns a promise that will resolve on success, and reject on failure
     */
    delete(url: string, parameters: any, headers: any): Promise<HTTPResponse>;
    /**
     * Make a sync DELETE request
     * @param url {string} The url to send the request to
     * @param parameters {Object} Parameters to send with the request
     * @param headers {Object} The headers to set for this request
     * @param success {function} A callback that is called when the request succeed
     * @param failure {function} A callback that is called when the request failed
     * @returns {string} returns a string that represents the requestId
     */
    deleteSync(url: string, parameters: any, headers: any, success: (result: HTTPResponse) => void, failure: (error: any) => void): string;
    /**
     * Make a HEAD request
     * @param url {string} The url to send the request to
     * @param parameters {Object} Parameters to send with the request
     * @param headers {Object} The headers to set for this request
     * @returns {Promise<HTTPResponse>} returns a promise that will resolve on success, and reject on failure
     */
    head(url: string, parameters: any, headers: any): Promise<HTTPResponse>;
    /**
     * Make a sync HEAD request
     * @param url {string} The url to send the request to
     * @param parameters {Object} Parameters to send with the request
     * @param headers {Object} The headers to set for this request
     * @param success {function} A callback that is called when the request succeed
     * @param failure {function} A callback that is called when the request failed
     * @returns {string} returns a string that represents the requestId
     */
    headSync(url: string, parameters: any, headers: any, success: (result: HTTPResponse) => void, failure: (error: any) => void): string;
    /**
     * Make an OPTIONS request
     * @param url {string} The url to send the request to
     * @param parameters {Object} Parameters to send with the request
     * @param headers {Object} The headers to set for this request
     * @returns {Promise<HTTPResponse>} returns a promise that will resolve on success, and reject on failure
     */
    options(url: string, parameters: any, headers: any): Promise<HTTPResponse>;
    /**
     * Make an sync OPTIONS request
     * @param url {string} The url to send the request to
     * @param parameters {Object} Parameters to send with the request
     * @param headers {Object} The headers to set for this request
     * @param success {function} A callback that is called when the request succeed
     * @param failure {function} A callback that is called when the request failed
     * @returns {string} returns a string that represents the requestId
     */
    optionsSync(url: string, parameters: any, headers: any, success: (result: HTTPResponse) => void, failure: (error: any) => void): string;
    /**
     *
     * @param url {string} The url to send the request to
     * @param body {Object} The body of the request
     * @param headers {Object} The headers to set for this request
     * @param filePath {string} The local path(s) of the file(s) to upload
     * @param name {string} The name(s) of the parameter to pass the file(s) along as
     * @returns {Promise<any>} returns a FileEntry promise that will resolve on success, and reject on failure
     */
    uploadFile(url: string, body: any, headers: any, filePath: string | string[], name: string | string[]): Promise<any>;
    /**
     *
     * @param url {string} The url to send the request to
     * @param body {Object} The body of the request
     * @param headers {Object} The headers to set for this request
     * @param filePath {string} The local path(s) of the file(s) to upload
     * @param name {string} The name(s) of the parameter to pass the file(s) along as
     * @param success {function} A callback that is called when the request succeed
     * @param failure {function} A callback that is called when the request failed
     * @returns {string} returns a string that represents the requestId
     */
    uploadFileSync(url: string, body: any, headers: any, filePath: string | string[], name: string | string[], success: (result: any) => void, failure: (error: any) => void): string;
    /**
     *
     * @param url {string} The url to send the request to
     * @param body {Object} The body of the request
     * @param headers {Object} The headers to set for this request
     * @param filePath {string} The path to download the file to, including the file name.
     * @returns {Promise<any>} returns a FileEntry promise that will resolve on success, and reject on failure
     */
    downloadFile(url: string, body: any, headers: any, filePath: string): Promise<any>;
    /**
     *
     * @param url {string} The url to send the request to
     * @param body {Object} The body of the request
     * @param headers {Object} The headers to set for this request
     * @param filePath {string} The path to download the file to, including the file name.
     * @param success {function} A callback that is called when the request succeed
     * @param failure {function} A callback that is called when the request failed
     * @returns {string} returns a string that represents the requestId
     */
    downloadFileSync(url: string, body: any, headers: any, filePath: string, success: (result: any) => void, failure: (error: any) => void): string;
    /**
     *
     * @param url {string} The url to send the request to
     * @param options {Object} options for individual request
     * @param options.method {string} request method
     * @param options.data {Object} payload to be send to the server (only applicable on post, put or patch methods)
     * @param options.params {Object} query params to be appended to the URL (only applicable on get, head, delete, upload or download methods)
     * @param options.serializer {string} data serializer to be used (only applicable on post, put or patch methods), defaults to global serializer value, see setDataSerializer for supported values
     * @param options.timeout {number} timeout value for the request in seconds, defaults to global timeout value
     * @param options.headers {Object} headers object (key value pair), will be merged with global values
     * @param options.filePath {string} file path(s) to be used during upload and download see uploadFile and downloadFile for detailed information
     * @param options.name {string} name(s) to be used during upload see uploadFile for detailed information
     * @param options.responseType {string} response type, defaults to text
     *
     * @returns {Promise<HTTPResponse>} returns a promise that will resolve on success, and reject on failure
     */
    sendRequest(url: string, options: {
        method: 'get' | 'post' | 'put' | 'patch' | 'head' | 'delete' | 'options' | 'upload' | 'download';
        data?: {
            [index: string]: any;
        };
        params?: {
            [index: string]: string | number;
        };
        serializer?: 'json' | 'urlencoded' | 'utf8' | 'multipart' | 'raw';
        timeout?: number;
        headers?: {
            [index: string]: string;
        };
        filePath?: string | string[];
        name?: string | string[];
        responseType?: 'text' | 'arraybuffer' | 'blob' | 'json';
    }): Promise<HTTPResponse>;
    /**
     *
     * @param url {string} The url to send the request to
     * @param options {Object} options for individual request
     * @param options.method {string} request method
     * @param options.data {Object} payload to be send to the server (only applicable on post, put or patch methods)
     * @param options.params {Object} query params to be appended to the URL (only applicable on get, head, delete, upload or download methods)
     * @param options.serializer {string} data serializer to be used (only applicable on post, put or patch methods), defaults to global serializer value, see setDataSerializer for supported values
     * @param options.timeout {number} timeout value for the request in seconds, defaults to global timeout value
     * @param options.headers {Object} headers object (key value pair), will be merged with global values
     * @param options.filePath {string} file path(s) to be used during upload and download see uploadFile and downloadFile for detailed information
     * @param options.name {string} name(s) to be used during upload see uploadFile for detailed information
     * @param options.responseType {string} response type, defaults to text
     * @param success {function} A callback that is called when the request succeed
     * @param failure {function} A callback that is called when the request failed
     *
     * @returns {string} returns a string that represents the requestId
     */
    sendRequestSync(url: string, options: {
        method: 'get' | 'post' | 'put' | 'patch' | 'head' | 'delete' | 'options' | 'upload' | 'download';
        data?: {
            [index: string]: any;
        };
        params?: {
            [index: string]: string | number;
        };
        serializer?: 'json' | 'urlencoded' | 'utf8' | 'multipart';
        timeout?: number;
        headers?: {
            [index: string]: string;
        };
        filePath?: string | string[];
        name?: string | string[];
        responseType?: 'text' | 'arraybuffer' | 'blob' | 'json';
    }, success: (result: HTTPResponse) => void, failure: (error: any) => void): string;
    /**
     * @param requestId {string} The RequestId of the request to abort
     */
    abort(requestId: string): Promise<AbortedResponse>;
    static Éµfac: Éµngcc0.ÉµÉµFactoryDef<HTTP, never>;
    static Éµprov: Éµngcc0.ÉµÉµInjectableDef<HTTP>;
}
export {};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZC50cyIsInNvdXJjZXMiOlsiaW5kZXguZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW9uaWNOYXRpdmVQbHVnaW4gfSBmcm9tICdAaW9uaWMtbmF0aXZlL2NvcmUnO1xuZXhwb3J0IGludGVyZmFjZSBIVFRQUmVzcG9uc2Uge1xuICAgIC8qKlxuICAgICAqIFRoZSBIVFRQIHN0YXR1cyBudW1iZXIgb2YgdGhlIHJlc3BvbnNlIG9yIGEgbmVnYXRpdmUgaW50ZXJuYWwgZXJyb3IgY29kZS5cbiAgICAgKi9cbiAgICBzdGF0dXM6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGVhZGVycyBvZiB0aGUgcmVzcG9uc2UuXG4gICAgICovXG4gICAgaGVhZGVyczoge1xuICAgICAgICBba2V5OiBzdHJpbmddOiBzdHJpbmc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgVVJMIG9mIHRoZSByZXNwb25zZS4gVGhpcyBwcm9wZXJ0eSB3aWxsIGJlIHRoZSBmaW5hbCBVUkwgb2J0YWluZWQgYWZ0ZXIgYW55IHJlZGlyZWN0cy5cbiAgICAgKi9cbiAgICB1cmw6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0YSB0aGF0IGlzIGluIHRoZSByZXNwb25zZS4gVGhpcyBwcm9wZXJ0eSB1c3VhbGx5IGV4aXN0cyB3aGVuIGEgcHJvbWlzZSByZXR1cm5lZCBieSBhIHJlcXVlc3QgbWV0aG9kIHJlc29sdmVzLlxuICAgICAqL1xuICAgIGRhdGE/OiBhbnk7XG4gICAgLyoqXG4gICAgICogRXJyb3IgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLiBUaGlzIHByb3BlcnR5IHVzdWFsbHkgZXhpc3RzIHdoZW4gYSBwcm9taXNlIHJldHVybmVkIGJ5IGEgcmVxdWVzdCBtZXRob2QgcmVqZWN0cy5cbiAgICAgKi9cbiAgICBlcnJvcj86IHN0cmluZztcbn1cbmludGVyZmFjZSBBYm9ydGVkUmVzcG9uc2Uge1xuICAgIGFib3J0ZWQ6IGJvb2xlYW47XG59XG4vKipcbiAqIEBuYW1lIEhUVFBcbiAqIEBkZXNjcmlwdGlvblxuICogQ29yZG92YSAvIFBob25lZ2FwIHBsdWdpbiBmb3IgY29tbXVuaWNhdGluZyB3aXRoIEhUVFAgc2VydmVycy4gU3VwcG9ydHMgaU9TIGFuZCBBbmRyb2lkLlxuICpcbiAqIEFkdmFudGFnZXMgb3ZlciBKYXZhc2NyaXB0IHJlcXVlc3RzOlxuICogLSBTU0wgLyBUTFMgUGlubmluZ1xuICogLSBDT1JTIHJlc3RyaWN0aW9ucyBkbyBub3QgYXBwbHlcbiAqIC0gSGFuZGxpbmcgb2YgSFRUUCBjb2RlIDQwMSAtIHJlYWQgbW9yZSBhdCBbSXNzdWUgQ0ItMjQxNV0oaHR0cHM6Ly9pc3N1ZXMuYXBhY2hlLm9yZy9qaXJhL2Jyb3dzZS9DQi0yNDE1KVxuICpcbiAqIEB1c2FnZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgSFRUUCB9IGZyb20gJ0Bpb25pYy1uYXRpdmUvaHR0cC9uZ3gnO1xuICpcbiAqIGNvbnN0cnVjdG9yKHByaXZhdGUgaHR0cDogSFRUUCkge31cbiAqXG4gKiAuLi5cbiAqXG4gKiB0aGlzLmh0dHAuZ2V0KCdodHRwOi8vaW9uaWMuaW8nLCB7fSwge30pXG4gKiAgIC50aGVuKGRhdGEgPT4ge1xuICpcbiAqICAgICBjb25zb2xlLmxvZyhkYXRhLnN0YXR1cyk7XG4gKiAgICAgY29uc29sZS5sb2coZGF0YS5kYXRhKTsgLy8gZGF0YSByZWNlaXZlZCBieSBzZXJ2ZXJcbiAqICAgICBjb25zb2xlLmxvZyhkYXRhLmhlYWRlcnMpO1xuICpcbiAqICAgfSlcbiAqICAgLmNhdGNoKGVycm9yID0+IHtcbiAqXG4gKiAgICAgY29uc29sZS5sb2coZXJyb3Iuc3RhdHVzKTtcbiAqICAgICBjb25zb2xlLmxvZyhlcnJvci5lcnJvcik7IC8vIGVycm9yIG1lc3NhZ2UgYXMgc3RyaW5nXG4gKiAgICAgY29uc29sZS5sb2coZXJyb3IuaGVhZGVycyk7XG4gKlxuICogICB9KTtcbiAqXG4gKiBgYGBcbiAqIEBpbnRlcmZhY2VzXG4gKiBIVFRQUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSFRUUCBleHRlbmRzIElvbmljTmF0aXZlUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGVudW0gcmVwcmVzZW50cyB0aGUgaW50ZXJuYWwgZXJyb3IgY29kZXMgd2hpY2ggY2FuIGJlIHJldHVybmVkIGluIGEgSFRUUFJlc3BvbnNlIG9iamVjdC5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICByZWFkb25seSBFcnJvckNvZGU6IHtcbiAgICAgICAgR0VORVJJQzogbnVtYmVyO1xuICAgICAgICBTU0xfRVhDRVBUSU9OOiBudW1iZXI7XG4gICAgICAgIFNFUlZFUl9OT1RfRk9VTkQ6IG51bWJlcjtcbiAgICAgICAgVElNRU9VVDogbnVtYmVyO1xuICAgICAgICBVTlNVUFBPUlRFRF9VUkw6IG51bWJlcjtcbiAgICAgICAgTk9UX0NPTk5FQ1RFRDogbnVtYmVyO1xuICAgICAgICBQT1NUX1BST0NFU1NJTkdfRkFJTEVEOiBudW1iZXI7XG4gICAgICAgIEFCT1JURUQ6IG51bWJlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgcmV0dXJucyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgYmFzaWMgSFRUUCBBdXRob3JpemF0aW9uIGhlYWRlciBvZiB0aGUgZm9ybS5cbiAgICAgKiBAcGFyYW0gdXNlcm5hbWUge3N0cmluZ30gVXNlcm5hbWVcbiAgICAgKiBAcGFyYW0gcGFzc3dvcmQge3N0cmluZ30gUGFzc3dvcmRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgYmFzaWMgSFRUUCBBdXRob3JpemF0aW9uIGhlYWRlciBvZiB0aGUgZm9ybSB7J0F1dGhvcml6YXRpb24nOiAnQmFzaWMgYmFzZTY0RW5jb2RlZFVzZXJuYW1lQW5kUGFzc3dvcmQnfVxuICAgICAqL1xuICAgIGdldEJhc2ljQXV0aEhlYWRlcih1c2VybmFtZTogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKToge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBzdHJpbmc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIHNldHMgdXAgYWxsIGZ1dHVyZSByZXF1ZXN0cyB0byB1c2UgQmFzaWMgSFRUUCBhdXRoZW50aWNhdGlvbiB3aXRoIHRoZSBnaXZlbiB1c2VybmFtZSBhbmQgcGFzc3dvcmQuXG4gICAgICogQHBhcmFtIHVzZXJuYW1lIHtzdHJpbmd9IFVzZXJuYW1lXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIHtzdHJpbmd9IFBhc3N3b3JkXG4gICAgICovXG4gICAgdXNlQmFzaWNBdXRoKHVzZXJuYW1lOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEdldCBhbGwgaGVhZGVycyBkZWZpbmVkIGZvciBhIGdpdmVuIGhvc3RuYW1lLlxuICAgICAqIEBwYXJhbSBob3N0IHtzdHJpbmd9IFRoZSBob3N0bmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHJldHVybiBhbGwgaGVhZGVycyBkZWZpbmVkIGZvciB0aGUgaG9zdG5hbWVcbiAgICAgKi9cbiAgICBnZXRIZWFkZXJzKGhvc3Q6IHN0cmluZyk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTZXQgYSBoZWFkZXIgZm9yIGFsbCBmdXR1cmUgcmVxdWVzdHMuIFRha2VzIGEgaG9zdG5hbWUsIGEgaGVhZGVyIGFuZCBhIHZhbHVlLlxuICAgICAqIEBwYXJhbSBob3N0IHtzdHJpbmd9IFRoZSBob3N0bmFtZSB0byBiZSB1c2VkIGZvciBzY29waW5nIHRoaXMgaGVhZGVyXG4gICAgICogQHBhcmFtIGhlYWRlciB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgaGVhZGVyXG4gICAgICogQHBhcmFtIHZhbHVlIHtzdHJpbmd9IFRoZSB2YWx1ZSBvZiB0aGUgaGVhZGVyXG4gICAgICovXG4gICAgc2V0SGVhZGVyKGhvc3Q6IHN0cmluZywgaGVhZGVyOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgZGF0YSBzZXJpYWxpemVyIHdoaWNoIHdpbGwgYmUgdXNlZCBmb3IgYWxsIGZ1dHVyZSBQT1NUIGFuZCBQVVQgcmVxdWVzdHMuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgY29uZmlndXJlZCBkYXRhIHNlcmlhbGl6ZXJcbiAgICAgKi9cbiAgICBnZXREYXRhU2VyaWFsaXplcigpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBkYXRhIHNlcmlhbGl6ZXIgd2hpY2ggd2lsbCBiZSB1c2VkIGZvciBhbGwgZnV0dXJlIFBPU1QsIFBVVCBhbmQgUEFUQ0ggcmVxdWVzdHMuIFRha2VzIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbmFtZSBvZiB0aGUgc2VyaWFsaXplci5cbiAgICAgKiBAcGFyYW0gc2VyaWFsaXplciB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgc2VyaWFsaXplci5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zaWxraW1lbi9jb3Jkb3ZhLXBsdWdpbi1hZHZhbmNlZC1odHRwI3NldGRhdGFzZXJpYWxpemVyXG4gICAgICovXG4gICAgc2V0RGF0YVNlcmlhbGl6ZXIoc2VyaWFsaXplcjogJ3VybGVuY29kZWQnIHwgJ2pzb24nIHwgJ3V0ZjgnIHwgJ211bHRpcGFydCcgfCAncmF3Jyk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQWRkIGEgY3VzdG9tIGNvb2tpZS5cbiAgICAgKiBAcGFyYW0gdXJsIHtzdHJpbmd9IFNjb3BlIG9mIHRoZSBjb29raWVcbiAgICAgKiBAcGFyYW0gY29va2llIHtzdHJpbmd9IFJGQyBjb21wbGlhbnQgY29va2llIHN0cmluZ1xuICAgICAqL1xuICAgIHNldENvb2tpZSh1cmw6IHN0cmluZywgY29va2llOiBzdHJpbmcpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBjb29raWVzLlxuICAgICAqL1xuICAgIGNsZWFyQ29va2llcygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBjb29raWVzIGZvciBnaXZlbiBVUkwuXG4gICAgICogQHBhcmFtIHVybCB7c3RyaW5nfVxuICAgICAqIEBwYXJhbSBjYlxuICAgICAqL1xuICAgIHJlbW92ZUNvb2tpZXModXJsOiBzdHJpbmcsIGNiOiAoKSA9PiB2b2lkKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIGNvb2tpZSBzdHJpbmcgZm9yIGdpdmVuIFVSTC5cbiAgICAgKiBAcGFyYW0gdXJsIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q29va2llU3RyaW5nKHVybDogc3RyaW5nKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEdldCBnbG9iYWwgcmVxdWVzdCB0aW1lb3V0IHZhbHVlIGluIHNlY29uZHMuXG4gICAgICogQHJldHVybnMge251bWJlcn0gcmV0dXJucyB0aGUgZ2xvYmFsIHJlcXVlc3QgdGltZW91dCB2YWx1ZVxuICAgICAqL1xuICAgIGdldFJlcXVlc3RUaW1lb3V0KCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBTZXQgZ2xvYmFsIHJlcXVlc3QgdGltZW91dCB2YWx1ZSBpbiBzZWNvbmRzLlxuICAgICAqIEBwYXJhbSB0aW1lb3V0IHtudW1iZXJ9IFRoZSB0aW1lb3V0IGluIHNlY29uZHMuIERlZmF1bHQgNjBcbiAgICAgKi9cbiAgICBzZXRSZXF1ZXN0VGltZW91dCh0aW1lb3V0OiBudW1iZXIpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJlc29sdmUgaWYgaXQgc2hvdWxkIGZvbGxvdyByZWRpcmVjdHMgYXV0b21hdGljYWxseS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIGl0IGlzIGNvbmZpZ3VyZWQgdG8gZm9sbG93IHJlZGlyZWN0cyBhdXRvbWF0aWNhbGx5XG4gICAgICovXG4gICAgZ2V0Rm9sbG93UmVkaXJlY3QoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmUgaWYgaXQgc2hvdWxkIGZvbGxvdyByZWRpcmVjdHMgYXV0b21hdGljYWxseS5cbiAgICAgKiBAcGFyYW0gZm9sbG93IHtib29sZWFufSBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBmb2xsb3dpbmcgcmVkaXJlY3RzIGF1dG9tYXRpY2FsbHlcbiAgICAgKi9cbiAgICBzZXRGb2xsb3dSZWRpcmVjdChmb2xsb3c6IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFNldCBzZXJ2ZXIgdHJ1c3QgbW9kZSwgYmVpbmcgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuICAgICAqIGRlZmF1bHQ6IGRlZmF1bHQgU1NMIHRydXN0c2hpcCBhbmQgaG9zdG5hbWUgdmVyaWZpY2F0aW9uIGhhbmRsaW5nIHVzaW5nIHN5c3RlbSdzIENBIGNlcnRzO1xuICAgICAqIGxlZ2FjeTogdXNlIGxlZ2FjeSBkZWZhdWx0IGJlaGF2aW9yICg8IDIuMC4zKSwgZXhjbHVkaW5nIHVzZXIgaW5zdGFsbGVkIENBIGNlcnRzIChvbmx5IGZvciBBbmRyb2lkKTtcbiAgICAgKiBub2NoZWNrOiBkaXNhYmxlIFNTTCBjZXJ0aWZpY2F0ZSBjaGVja2luZyBhbmQgaG9zdG5hbWUgdmVyaWZpY2F0aW9uLCB0cnVzdGluZyBhbGwgY2VydHMgKG1lYW50IHRvIGJlIHVzZWQgb25seSBmb3IgdGVzdGluZyBwdXJwb3Nlcyk7XG4gICAgICogcGlubmVkOiB0cnVzdCBvbmx5IHByb3ZpZGVkIGNlcnRpZmljYXRlcztcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zaWxraW1lbi9jb3Jkb3ZhLXBsdWdpbi1hZHZhbmNlZC1odHRwI3NldHNlcnZlcnRydXN0bW9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlIHNlcnZlciB0cnVzdCBtb2RlXG4gICAgICovXG4gICAgc2V0U2VydmVyVHJ1c3RNb2RlKG1vZGU6ICdkZWZhdWx0JyB8ICdsZWdhY3knIHwgJ25vY2hlY2snIHwgJ3Bpbm5lZCcpOiBQcm9taXNlPHZvaWQ+O1xuICAgIC8qKlxuICAgICAqIE1ha2UgYSBQT1NUIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gdXJsIHtzdHJpbmd9IFRoZSB1cmwgdG8gc2VuZCB0aGUgcmVxdWVzdCB0b1xuICAgICAqIEBwYXJhbSBib2R5IHtPYmplY3R9IFRoZSBib2R5IG9mIHRoZSByZXF1ZXN0XG4gICAgICogQHBhcmFtIGhlYWRlcnMge09iamVjdH0gVGhlIGhlYWRlcnMgdG8gc2V0IGZvciB0aGlzIHJlcXVlc3RcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxIVFRQUmVzcG9uc2U+fSByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSBvbiBzdWNjZXNzLCBhbmQgcmVqZWN0IG9uIGZhaWx1cmVcbiAgICAgKi9cbiAgICBwb3N0KHVybDogc3RyaW5nLCBib2R5OiBhbnksIGhlYWRlcnM6IGFueSk6IFByb21pc2U8SFRUUFJlc3BvbnNlPjtcbiAgICAvKipcbiAgICAgKiBNYWtlIGEgc3luYyBQT1NUIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gdXJsIHtzdHJpbmd9IFRoZSB1cmwgdG8gc2VuZCB0aGUgcmVxdWVzdCB0b1xuICAgICAqIEBwYXJhbSBib2R5IHtPYmplY3R9IFRoZSBib2R5IG9mIHRoZSByZXF1ZXN0XG4gICAgICogQHBhcmFtIGhlYWRlcnMge09iamVjdH0gVGhlIGhlYWRlcnMgdG8gc2V0IGZvciB0aGlzIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gc3VjY2VzcyB7ZnVuY3Rpb259IEEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgcmVxdWVzdCBzdWNjZWVkXG4gICAgICogQHBhcmFtIGZhaWx1cmUge2Z1bmN0aW9ufSBBIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3QgZmFpbGVkXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcmV0dXJucyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIHJlcXVlc3RJZFxuICAgICAqL1xuICAgIHBvc3RTeW5jKHVybDogc3RyaW5nLCBib2R5OiBhbnksIGhlYWRlcnM6IGFueSwgc3VjY2VzczogKHJlc3VsdDogSFRUUFJlc3BvbnNlKSA9PiB2b2lkLCBmYWlsdXJlOiAoZXJyb3I6IGFueSkgPT4gdm9pZCk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBNYWtlIGEgR0VUIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gdXJsIHtzdHJpbmd9IFRoZSB1cmwgdG8gc2VuZCB0aGUgcmVxdWVzdCB0b1xuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIHtPYmplY3R9IFBhcmFtZXRlcnMgdG8gc2VuZCB3aXRoIHRoZSByZXF1ZXN0XG4gICAgICogQHBhcmFtIGhlYWRlcnMge09iamVjdH0gVGhlIGhlYWRlcnMgdG8gc2V0IGZvciB0aGlzIHJlcXVlc3RcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxIVFRQUmVzcG9uc2U+fSByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSBvbiBzdWNjZXNzLCBhbmQgcmVqZWN0IG9uIGZhaWx1cmVcbiAgICAgKi9cbiAgICBnZXQodXJsOiBzdHJpbmcsIHBhcmFtZXRlcnM6IGFueSwgaGVhZGVyczogYW55KTogUHJvbWlzZTxIVFRQUmVzcG9uc2U+O1xuICAgIC8qKlxuICAgICAqIE1ha2UgYSBzeW5jIEdFVCByZXF1ZXN0XG4gICAgICogQHBhcmFtIHVybCB7c3RyaW5nfSBUaGUgdXJsIHRvIHNlbmQgdGhlIHJlcXVlc3QgdG9cbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVycyB7T2JqZWN0fSBQYXJhbWV0ZXJzIHRvIHNlbmQgd2l0aCB0aGUgcmVxdWVzdFxuICAgICAqIEBwYXJhbSBoZWFkZXJzIHtPYmplY3R9IFRoZSBoZWFkZXJzIHRvIHNldCBmb3IgdGhpcyByZXF1ZXN0XG4gICAgICogQHBhcmFtIHN1Y2Nlc3Mge2Z1bmN0aW9ufSBBIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3Qgc3VjY2VlZFxuICAgICAqIEBwYXJhbSBmYWlsdXJlIHtmdW5jdGlvbn0gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSByZXF1ZXN0IGZhaWxlZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHJldHVybnMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSByZXF1ZXN0SWRcbiAgICAgKi9cbiAgICBnZXRTeW5jKHVybDogc3RyaW5nLCBwYXJhbWV0ZXJzOiBhbnksIGhlYWRlcnM6IGFueSwgc3VjY2VzczogKHJlc3VsdDogSFRUUFJlc3BvbnNlKSA9PiB2b2lkLCBmYWlsdXJlOiAoZXJyb3I6IGFueSkgPT4gdm9pZCk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBNYWtlIGEgUFVUIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gdXJsIHtzdHJpbmd9IFRoZSB1cmwgdG8gc2VuZCB0aGUgcmVxdWVzdCB0b1xuICAgICAqIEBwYXJhbSBib2R5IHtPYmplY3R9IFRoZSBib2R5IG9mIHRoZSByZXF1ZXN0XG4gICAgICogQHBhcmFtIGhlYWRlcnMge09iamVjdH0gVGhlIGhlYWRlcnMgdG8gc2V0IGZvciB0aGlzIHJlcXVlc3RcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxIVFRQUmVzcG9uc2U+fSByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSBvbiBzdWNjZXNzLCBhbmQgcmVqZWN0IG9uIGZhaWx1cmVcbiAgICAgKi9cbiAgICBwdXQodXJsOiBzdHJpbmcsIGJvZHk6IGFueSwgaGVhZGVyczogYW55KTogUHJvbWlzZTxIVFRQUmVzcG9uc2U+O1xuICAgIC8qKlxuICAgICAqIE1ha2UgYSBzeW5jIFBVVCByZXF1ZXN0XG4gICAgICogQHBhcmFtIHVybCB7c3RyaW5nfSBUaGUgdXJsIHRvIHNlbmQgdGhlIHJlcXVlc3QgdG9cbiAgICAgKiBAcGFyYW0gYm9keSB7T2JqZWN0fSBUaGUgYm9keSBvZiB0aGUgcmVxdWVzdFxuICAgICAqIEBwYXJhbSBoZWFkZXJzIHtPYmplY3R9IFRoZSBoZWFkZXJzIHRvIHNldCBmb3IgdGhpcyByZXF1ZXN0XG4gICAgICogQHBhcmFtIHN1Y2Nlc3Mge2Z1bmN0aW9ufSBBIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3Qgc3VjY2VlZFxuICAgICAqIEBwYXJhbSBmYWlsdXJlIHtmdW5jdGlvbn0gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSByZXF1ZXN0IGZhaWxlZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHJldHVybnMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSByZXF1ZXN0SWRcbiAgICAgKi9cbiAgICBwdXRTeW5jKHVybDogc3RyaW5nLCBib2R5OiBhbnksIGhlYWRlcnM6IGFueSwgc3VjY2VzczogKHJlc3VsdDogSFRUUFJlc3BvbnNlKSA9PiB2b2lkLCBmYWlsdXJlOiAoZXJyb3I6IGFueSkgPT4gdm9pZCk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBNYWtlIGEgUEFUQ0ggcmVxdWVzdFxuICAgICAqIEBwYXJhbSB1cmwge3N0cmluZ30gVGhlIHVybCB0byBzZW5kIHRoZSByZXF1ZXN0IHRvXG4gICAgICogQHBhcmFtIGJvZHkge09iamVjdH0gVGhlIGJvZHkgb2YgdGhlIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gaGVhZGVycyB7T2JqZWN0fSBUaGUgaGVhZGVycyB0byBzZXQgZm9yIHRoaXMgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEhUVFBSZXNwb25zZT59IHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIG9uIHN1Y2Nlc3MsIGFuZCByZWplY3Qgb24gZmFpbHVyZVxuICAgICAqL1xuICAgIHBhdGNoKHVybDogc3RyaW5nLCBib2R5OiBhbnksIGhlYWRlcnM6IGFueSk6IFByb21pc2U8SFRUUFJlc3BvbnNlPjtcbiAgICAvKipcbiAgICAgKiBNYWtlIGEgc3luYyBQQVRDSCByZXF1ZXN0XG4gICAgICogQHBhcmFtIHVybCB7c3RyaW5nfSBUaGUgdXJsIHRvIHNlbmQgdGhlIHJlcXVlc3QgdG9cbiAgICAgKiBAcGFyYW0gYm9keSB7T2JqZWN0fSBUaGUgYm9keSBvZiB0aGUgcmVxdWVzdFxuICAgICAqIEBwYXJhbSBoZWFkZXJzIHtPYmplY3R9IFRoZSBoZWFkZXJzIHRvIHNldCBmb3IgdGhpcyByZXF1ZXN0XG4gICAgICogQHBhcmFtIHN1Y2Nlc3Mge2Z1bmN0aW9ufSBBIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3Qgc3VjY2VlZFxuICAgICAqIEBwYXJhbSBmYWlsdXJlIHtmdW5jdGlvbn0gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSByZXF1ZXN0IGZhaWxlZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHJldHVybnMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSByZXF1ZXN0SWRcbiAgICAgKi9cbiAgICBwYXRjaFN5bmModXJsOiBzdHJpbmcsIGJvZHk6IGFueSwgaGVhZGVyczogYW55LCBzdWNjZXNzOiAocmVzdWx0OiBIVFRQUmVzcG9uc2UpID0+IHZvaWQsIGZhaWx1cmU6IChlcnJvcjogYW55KSA9PiB2b2lkKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIE1ha2UgYSBERUxFVEUgcmVxdWVzdFxuICAgICAqIEBwYXJhbSB1cmwge3N0cmluZ30gVGhlIHVybCB0byBzZW5kIHRoZSByZXF1ZXN0IHRvXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMge09iamVjdH0gUGFyYW1ldGVycyB0byBzZW5kIHdpdGggdGhlIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gaGVhZGVycyB7T2JqZWN0fSBUaGUgaGVhZGVycyB0byBzZXQgZm9yIHRoaXMgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEhUVFBSZXNwb25zZT59IHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIG9uIHN1Y2Nlc3MsIGFuZCByZWplY3Qgb24gZmFpbHVyZVxuICAgICAqL1xuICAgIGRlbGV0ZSh1cmw6IHN0cmluZywgcGFyYW1ldGVyczogYW55LCBoZWFkZXJzOiBhbnkpOiBQcm9taXNlPEhUVFBSZXNwb25zZT47XG4gICAgLyoqXG4gICAgICogTWFrZSBhIHN5bmMgREVMRVRFIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gdXJsIHtzdHJpbmd9IFRoZSB1cmwgdG8gc2VuZCB0aGUgcmVxdWVzdCB0b1xuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIHtPYmplY3R9IFBhcmFtZXRlcnMgdG8gc2VuZCB3aXRoIHRoZSByZXF1ZXN0XG4gICAgICogQHBhcmFtIGhlYWRlcnMge09iamVjdH0gVGhlIGhlYWRlcnMgdG8gc2V0IGZvciB0aGlzIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gc3VjY2VzcyB7ZnVuY3Rpb259IEEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgcmVxdWVzdCBzdWNjZWVkXG4gICAgICogQHBhcmFtIGZhaWx1cmUge2Z1bmN0aW9ufSBBIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3QgZmFpbGVkXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcmV0dXJucyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIHJlcXVlc3RJZFxuICAgICAqL1xuICAgIGRlbGV0ZVN5bmModXJsOiBzdHJpbmcsIHBhcmFtZXRlcnM6IGFueSwgaGVhZGVyczogYW55LCBzdWNjZXNzOiAocmVzdWx0OiBIVFRQUmVzcG9uc2UpID0+IHZvaWQsIGZhaWx1cmU6IChlcnJvcjogYW55KSA9PiB2b2lkKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIE1ha2UgYSBIRUFEIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gdXJsIHtzdHJpbmd9IFRoZSB1cmwgdG8gc2VuZCB0aGUgcmVxdWVzdCB0b1xuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIHtPYmplY3R9IFBhcmFtZXRlcnMgdG8gc2VuZCB3aXRoIHRoZSByZXF1ZXN0XG4gICAgICogQHBhcmFtIGhlYWRlcnMge09iamVjdH0gVGhlIGhlYWRlcnMgdG8gc2V0IGZvciB0aGlzIHJlcXVlc3RcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxIVFRQUmVzcG9uc2U+fSByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSBvbiBzdWNjZXNzLCBhbmQgcmVqZWN0IG9uIGZhaWx1cmVcbiAgICAgKi9cbiAgICBoZWFkKHVybDogc3RyaW5nLCBwYXJhbWV0ZXJzOiBhbnksIGhlYWRlcnM6IGFueSk6IFByb21pc2U8SFRUUFJlc3BvbnNlPjtcbiAgICAvKipcbiAgICAgKiBNYWtlIGEgc3luYyBIRUFEIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gdXJsIHtzdHJpbmd9IFRoZSB1cmwgdG8gc2VuZCB0aGUgcmVxdWVzdCB0b1xuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIHtPYmplY3R9IFBhcmFtZXRlcnMgdG8gc2VuZCB3aXRoIHRoZSByZXF1ZXN0XG4gICAgICogQHBhcmFtIGhlYWRlcnMge09iamVjdH0gVGhlIGhlYWRlcnMgdG8gc2V0IGZvciB0aGlzIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gc3VjY2VzcyB7ZnVuY3Rpb259IEEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgcmVxdWVzdCBzdWNjZWVkXG4gICAgICogQHBhcmFtIGZhaWx1cmUge2Z1bmN0aW9ufSBBIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3QgZmFpbGVkXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcmV0dXJucyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIHJlcXVlc3RJZFxuICAgICAqL1xuICAgIGhlYWRTeW5jKHVybDogc3RyaW5nLCBwYXJhbWV0ZXJzOiBhbnksIGhlYWRlcnM6IGFueSwgc3VjY2VzczogKHJlc3VsdDogSFRUUFJlc3BvbnNlKSA9PiB2b2lkLCBmYWlsdXJlOiAoZXJyb3I6IGFueSkgPT4gdm9pZCk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBNYWtlIGFuIE9QVElPTlMgcmVxdWVzdFxuICAgICAqIEBwYXJhbSB1cmwge3N0cmluZ30gVGhlIHVybCB0byBzZW5kIHRoZSByZXF1ZXN0IHRvXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMge09iamVjdH0gUGFyYW1ldGVycyB0byBzZW5kIHdpdGggdGhlIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gaGVhZGVycyB7T2JqZWN0fSBUaGUgaGVhZGVycyB0byBzZXQgZm9yIHRoaXMgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEhUVFBSZXNwb25zZT59IHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIG9uIHN1Y2Nlc3MsIGFuZCByZWplY3Qgb24gZmFpbHVyZVxuICAgICAqL1xuICAgIG9wdGlvbnModXJsOiBzdHJpbmcsIHBhcmFtZXRlcnM6IGFueSwgaGVhZGVyczogYW55KTogUHJvbWlzZTxIVFRQUmVzcG9uc2U+O1xuICAgIC8qKlxuICAgICAqIE1ha2UgYW4gc3luYyBPUFRJT05TIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gdXJsIHtzdHJpbmd9IFRoZSB1cmwgdG8gc2VuZCB0aGUgcmVxdWVzdCB0b1xuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIHtPYmplY3R9IFBhcmFtZXRlcnMgdG8gc2VuZCB3aXRoIHRoZSByZXF1ZXN0XG4gICAgICogQHBhcmFtIGhlYWRlcnMge09iamVjdH0gVGhlIGhlYWRlcnMgdG8gc2V0IGZvciB0aGlzIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gc3VjY2VzcyB7ZnVuY3Rpb259IEEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgcmVxdWVzdCBzdWNjZWVkXG4gICAgICogQHBhcmFtIGZhaWx1cmUge2Z1bmN0aW9ufSBBIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3QgZmFpbGVkXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcmV0dXJucyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIHJlcXVlc3RJZFxuICAgICAqL1xuICAgIG9wdGlvbnNTeW5jKHVybDogc3RyaW5nLCBwYXJhbWV0ZXJzOiBhbnksIGhlYWRlcnM6IGFueSwgc3VjY2VzczogKHJlc3VsdDogSFRUUFJlc3BvbnNlKSA9PiB2b2lkLCBmYWlsdXJlOiAoZXJyb3I6IGFueSkgPT4gdm9pZCk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwge3N0cmluZ30gVGhlIHVybCB0byBzZW5kIHRoZSByZXF1ZXN0IHRvXG4gICAgICogQHBhcmFtIGJvZHkge09iamVjdH0gVGhlIGJvZHkgb2YgdGhlIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gaGVhZGVycyB7T2JqZWN0fSBUaGUgaGVhZGVycyB0byBzZXQgZm9yIHRoaXMgcmVxdWVzdFxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCB7c3RyaW5nfSBUaGUgbG9jYWwgcGF0aChzKSBvZiB0aGUgZmlsZShzKSB0byB1cGxvYWRcbiAgICAgKiBAcGFyYW0gbmFtZSB7c3RyaW5nfSBUaGUgbmFtZShzKSBvZiB0aGUgcGFyYW1ldGVyIHRvIHBhc3MgdGhlIGZpbGUocykgYWxvbmcgYXNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSByZXR1cm5zIGEgRmlsZUVudHJ5IHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgb24gc3VjY2VzcywgYW5kIHJlamVjdCBvbiBmYWlsdXJlXG4gICAgICovXG4gICAgdXBsb2FkRmlsZSh1cmw6IHN0cmluZywgYm9keTogYW55LCBoZWFkZXJzOiBhbnksIGZpbGVQYXRoOiBzdHJpbmcgfCBzdHJpbmdbXSwgbmFtZTogc3RyaW5nIHwgc3RyaW5nW10pOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIHtzdHJpbmd9IFRoZSB1cmwgdG8gc2VuZCB0aGUgcmVxdWVzdCB0b1xuICAgICAqIEBwYXJhbSBib2R5IHtPYmplY3R9IFRoZSBib2R5IG9mIHRoZSByZXF1ZXN0XG4gICAgICogQHBhcmFtIGhlYWRlcnMge09iamVjdH0gVGhlIGhlYWRlcnMgdG8gc2V0IGZvciB0aGlzIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gZmlsZVBhdGgge3N0cmluZ30gVGhlIGxvY2FsIHBhdGgocykgb2YgdGhlIGZpbGUocykgdG8gdXBsb2FkXG4gICAgICogQHBhcmFtIG5hbWUge3N0cmluZ30gVGhlIG5hbWUocykgb2YgdGhlIHBhcmFtZXRlciB0byBwYXNzIHRoZSBmaWxlKHMpIGFsb25nIGFzXG4gICAgICogQHBhcmFtIHN1Y2Nlc3Mge2Z1bmN0aW9ufSBBIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3Qgc3VjY2VlZFxuICAgICAqIEBwYXJhbSBmYWlsdXJlIHtmdW5jdGlvbn0gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSByZXF1ZXN0IGZhaWxlZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHJldHVybnMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSByZXF1ZXN0SWRcbiAgICAgKi9cbiAgICB1cGxvYWRGaWxlU3luYyh1cmw6IHN0cmluZywgYm9keTogYW55LCBoZWFkZXJzOiBhbnksIGZpbGVQYXRoOiBzdHJpbmcgfCBzdHJpbmdbXSwgbmFtZTogc3RyaW5nIHwgc3RyaW5nW10sIHN1Y2Nlc3M6IChyZXN1bHQ6IGFueSkgPT4gdm9pZCwgZmFpbHVyZTogKGVycm9yOiBhbnkpID0+IHZvaWQpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIHtzdHJpbmd9IFRoZSB1cmwgdG8gc2VuZCB0aGUgcmVxdWVzdCB0b1xuICAgICAqIEBwYXJhbSBib2R5IHtPYmplY3R9IFRoZSBib2R5IG9mIHRoZSByZXF1ZXN0XG4gICAgICogQHBhcmFtIGhlYWRlcnMge09iamVjdH0gVGhlIGhlYWRlcnMgdG8gc2V0IGZvciB0aGlzIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gZmlsZVBhdGgge3N0cmluZ30gVGhlIHBhdGggdG8gZG93bmxvYWQgdGhlIGZpbGUgdG8sIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IHJldHVybnMgYSBGaWxlRW50cnkgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSBvbiBzdWNjZXNzLCBhbmQgcmVqZWN0IG9uIGZhaWx1cmVcbiAgICAgKi9cbiAgICBkb3dubG9hZEZpbGUodXJsOiBzdHJpbmcsIGJvZHk6IGFueSwgaGVhZGVyczogYW55LCBmaWxlUGF0aDogc3RyaW5nKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHVybCB7c3RyaW5nfSBUaGUgdXJsIHRvIHNlbmQgdGhlIHJlcXVlc3QgdG9cbiAgICAgKiBAcGFyYW0gYm9keSB7T2JqZWN0fSBUaGUgYm9keSBvZiB0aGUgcmVxdWVzdFxuICAgICAqIEBwYXJhbSBoZWFkZXJzIHtPYmplY3R9IFRoZSBoZWFkZXJzIHRvIHNldCBmb3IgdGhpcyByZXF1ZXN0XG4gICAgICogQHBhcmFtIGZpbGVQYXRoIHtzdHJpbmd9IFRoZSBwYXRoIHRvIGRvd25sb2FkIHRoZSBmaWxlIHRvLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS5cbiAgICAgKiBAcGFyYW0gc3VjY2VzcyB7ZnVuY3Rpb259IEEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgcmVxdWVzdCBzdWNjZWVkXG4gICAgICogQHBhcmFtIGZhaWx1cmUge2Z1bmN0aW9ufSBBIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3QgZmFpbGVkXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcmV0dXJucyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIHJlcXVlc3RJZFxuICAgICAqL1xuICAgIGRvd25sb2FkRmlsZVN5bmModXJsOiBzdHJpbmcsIGJvZHk6IGFueSwgaGVhZGVyczogYW55LCBmaWxlUGF0aDogc3RyaW5nLCBzdWNjZXNzOiAocmVzdWx0OiBhbnkpID0+IHZvaWQsIGZhaWx1cmU6IChlcnJvcjogYW55KSA9PiB2b2lkKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHVybCB7c3RyaW5nfSBUaGUgdXJsIHRvIHNlbmQgdGhlIHJlcXVlc3QgdG9cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSBvcHRpb25zIGZvciBpbmRpdmlkdWFsIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5tZXRob2Qge3N0cmluZ30gcmVxdWVzdCBtZXRob2RcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kYXRhIHtPYmplY3R9IHBheWxvYWQgdG8gYmUgc2VuZCB0byB0aGUgc2VydmVyIChvbmx5IGFwcGxpY2FibGUgb24gcG9zdCwgcHV0IG9yIHBhdGNoIG1ldGhvZHMpXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFyYW1zIHtPYmplY3R9IHF1ZXJ5IHBhcmFtcyB0byBiZSBhcHBlbmRlZCB0byB0aGUgVVJMIChvbmx5IGFwcGxpY2FibGUgb24gZ2V0LCBoZWFkLCBkZWxldGUsIHVwbG9hZCBvciBkb3dubG9hZCBtZXRob2RzKVxuICAgICAqIEBwYXJhbSBvcHRpb25zLnNlcmlhbGl6ZXIge3N0cmluZ30gZGF0YSBzZXJpYWxpemVyIHRvIGJlIHVzZWQgKG9ubHkgYXBwbGljYWJsZSBvbiBwb3N0LCBwdXQgb3IgcGF0Y2ggbWV0aG9kcyksIGRlZmF1bHRzIHRvIGdsb2JhbCBzZXJpYWxpemVyIHZhbHVlLCBzZWUgc2V0RGF0YVNlcmlhbGl6ZXIgZm9yIHN1cHBvcnRlZCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50aW1lb3V0IHtudW1iZXJ9IHRpbWVvdXQgdmFsdWUgZm9yIHRoZSByZXF1ZXN0IGluIHNlY29uZHMsIGRlZmF1bHRzIHRvIGdsb2JhbCB0aW1lb3V0IHZhbHVlXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaGVhZGVycyB7T2JqZWN0fSBoZWFkZXJzIG9iamVjdCAoa2V5IHZhbHVlIHBhaXIpLCB3aWxsIGJlIG1lcmdlZCB3aXRoIGdsb2JhbCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5maWxlUGF0aCB7c3RyaW5nfSBmaWxlIHBhdGgocykgdG8gYmUgdXNlZCBkdXJpbmcgdXBsb2FkIGFuZCBkb3dubG9hZCBzZWUgdXBsb2FkRmlsZSBhbmQgZG93bmxvYWRGaWxlIGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUge3N0cmluZ30gbmFtZShzKSB0byBiZSB1c2VkIGR1cmluZyB1cGxvYWQgc2VlIHVwbG9hZEZpbGUgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVzcG9uc2VUeXBlIHtzdHJpbmd9IHJlc3BvbnNlIHR5cGUsIGRlZmF1bHRzIHRvIHRleHRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEhUVFBSZXNwb25zZT59IHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIG9uIHN1Y2Nlc3MsIGFuZCByZWplY3Qgb24gZmFpbHVyZVxuICAgICAqL1xuICAgIHNlbmRSZXF1ZXN0KHVybDogc3RyaW5nLCBvcHRpb25zOiB7XG4gICAgICAgIG1ldGhvZDogJ2dldCcgfCAncG9zdCcgfCAncHV0JyB8ICdwYXRjaCcgfCAnaGVhZCcgfCAnZGVsZXRlJyB8ICdvcHRpb25zJyB8ICd1cGxvYWQnIHwgJ2Rvd25sb2FkJztcbiAgICAgICAgZGF0YT86IHtcbiAgICAgICAgICAgIFtpbmRleDogc3RyaW5nXTogYW55O1xuICAgICAgICB9O1xuICAgICAgICBwYXJhbXM/OiB7XG4gICAgICAgICAgICBbaW5kZXg6IHN0cmluZ106IHN0cmluZyB8IG51bWJlcjtcbiAgICAgICAgfTtcbiAgICAgICAgc2VyaWFsaXplcj86ICdqc29uJyB8ICd1cmxlbmNvZGVkJyB8ICd1dGY4JyB8ICdtdWx0aXBhcnQnIHwgJ3Jhdyc7XG4gICAgICAgIHRpbWVvdXQ/OiBudW1iZXI7XG4gICAgICAgIGhlYWRlcnM/OiB7XG4gICAgICAgICAgICBbaW5kZXg6IHN0cmluZ106IHN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgZmlsZVBhdGg/OiBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgICAgICAgbmFtZT86IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgICAgICByZXNwb25zZVR5cGU/OiAndGV4dCcgfCAnYXJyYXlidWZmZXInIHwgJ2Jsb2InIHwgJ2pzb24nO1xuICAgIH0pOiBQcm9taXNlPEhUVFBSZXNwb25zZT47XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIHtzdHJpbmd9IFRoZSB1cmwgdG8gc2VuZCB0aGUgcmVxdWVzdCB0b1xuICAgICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IG9wdGlvbnMgZm9yIGluZGl2aWR1YWwgcmVxdWVzdFxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1ldGhvZCB7c3RyaW5nfSByZXF1ZXN0IG1ldGhvZFxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRhdGEge09iamVjdH0gcGF5bG9hZCB0byBiZSBzZW5kIHRvIHRoZSBzZXJ2ZXIgKG9ubHkgYXBwbGljYWJsZSBvbiBwb3N0LCBwdXQgb3IgcGF0Y2ggbWV0aG9kcylcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wYXJhbXMge09iamVjdH0gcXVlcnkgcGFyYW1zIHRvIGJlIGFwcGVuZGVkIHRvIHRoZSBVUkwgKG9ubHkgYXBwbGljYWJsZSBvbiBnZXQsIGhlYWQsIGRlbGV0ZSwgdXBsb2FkIG9yIGRvd25sb2FkIG1ldGhvZHMpXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc2VyaWFsaXplciB7c3RyaW5nfSBkYXRhIHNlcmlhbGl6ZXIgdG8gYmUgdXNlZCAob25seSBhcHBsaWNhYmxlIG9uIHBvc3QsIHB1dCBvciBwYXRjaCBtZXRob2RzKSwgZGVmYXVsdHMgdG8gZ2xvYmFsIHNlcmlhbGl6ZXIgdmFsdWUsIHNlZSBzZXREYXRhU2VyaWFsaXplciBmb3Igc3VwcG9ydGVkIHZhbHVlc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnRpbWVvdXQge251bWJlcn0gdGltZW91dCB2YWx1ZSBmb3IgdGhlIHJlcXVlc3QgaW4gc2Vjb25kcywgZGVmYXVsdHMgdG8gZ2xvYmFsIHRpbWVvdXQgdmFsdWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkZXJzIHtPYmplY3R9IGhlYWRlcnMgb2JqZWN0IChrZXkgdmFsdWUgcGFpciksIHdpbGwgYmUgbWVyZ2VkIHdpdGggZ2xvYmFsIHZhbHVlc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmZpbGVQYXRoIHtzdHJpbmd9IGZpbGUgcGF0aChzKSB0byBiZSB1c2VkIGR1cmluZyB1cGxvYWQgYW5kIGRvd25sb2FkIHNlZSB1cGxvYWRGaWxlIGFuZCBkb3dubG9hZEZpbGUgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uXG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZSB7c3RyaW5nfSBuYW1lKHMpIHRvIGJlIHVzZWQgZHVyaW5nIHVwbG9hZCBzZWUgdXBsb2FkRmlsZSBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb25cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZXNwb25zZVR5cGUge3N0cmluZ30gcmVzcG9uc2UgdHlwZSwgZGVmYXVsdHMgdG8gdGV4dFxuICAgICAqIEBwYXJhbSBzdWNjZXNzIHtmdW5jdGlvbn0gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSByZXF1ZXN0IHN1Y2NlZWRcbiAgICAgKiBAcGFyYW0gZmFpbHVyZSB7ZnVuY3Rpb259IEEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgcmVxdWVzdCBmYWlsZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHJldHVybnMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSByZXF1ZXN0SWRcbiAgICAgKi9cbiAgICBzZW5kUmVxdWVzdFN5bmModXJsOiBzdHJpbmcsIG9wdGlvbnM6IHtcbiAgICAgICAgbWV0aG9kOiAnZ2V0JyB8ICdwb3N0JyB8ICdwdXQnIHwgJ3BhdGNoJyB8ICdoZWFkJyB8ICdkZWxldGUnIHwgJ29wdGlvbnMnIHwgJ3VwbG9hZCcgfCAnZG93bmxvYWQnO1xuICAgICAgICBkYXRhPzoge1xuICAgICAgICAgICAgW2luZGV4OiBzdHJpbmddOiBhbnk7XG4gICAgICAgIH07XG4gICAgICAgIHBhcmFtcz86IHtcbiAgICAgICAgICAgIFtpbmRleDogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyO1xuICAgICAgICB9O1xuICAgICAgICBzZXJpYWxpemVyPzogJ2pzb24nIHwgJ3VybGVuY29kZWQnIHwgJ3V0ZjgnIHwgJ211bHRpcGFydCc7XG4gICAgICAgIHRpbWVvdXQ/OiBudW1iZXI7XG4gICAgICAgIGhlYWRlcnM/OiB7XG4gICAgICAgICAgICBbaW5kZXg6IHN0cmluZ106IHN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgZmlsZVBhdGg/OiBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgICAgICAgbmFtZT86IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgICAgICByZXNwb25zZVR5cGU/OiAndGV4dCcgfCAnYXJyYXlidWZmZXInIHwgJ2Jsb2InIHwgJ2pzb24nO1xuICAgIH0sIHN1Y2Nlc3M6IChyZXN1bHQ6IEhUVFBSZXNwb25zZSkgPT4gdm9pZCwgZmFpbHVyZTogKGVycm9yOiBhbnkpID0+IHZvaWQpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHJlcXVlc3RJZCB7c3RyaW5nfSBUaGUgUmVxdWVzdElkIG9mIHRoZSByZXF1ZXN0IHRvIGFib3J0XG4gICAgICovXG4gICAgYWJvcnQocmVxdWVzdElkOiBzdHJpbmcpOiBQcm9taXNlPEFib3J0ZWRSZXNwb25zZT47XG59XG5leHBvcnQge307XG4iXX0=